# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" class="solvedac-tier" width=20> [배열 탈출](https://www.acmicpc.net/problem/11909)

## 문제
상수는 2차원 배열 A[1..n][1..n] (n≥2, n은 자연수)을 가지고 있습니다. 이 배열의 각 원소는 1 이상 222 이하의 정수입니다.

배열을 가지고 놀던 상수를 본 승현이는, 질투심이 불타올라 상수를 A[1][1]에 가둬 버렸습니다! 최소한의 양심이 있던 승현이는 A[n][n]에 출구를 만들어 놓고 이 사실을 상수에게 알려줬습니다.

<p align='center'><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11909/1.png"></p>

<p align='center'>[그림 1] n=4라면 상수는 A[1,1]에 있고, 출구는 A[4][4]에 있습니다.</p>

상수는 가능한 한 빨리 출구인 A[n][n]에 도달하고자 합니다. 상수가 A[i][j]에 있다고 가정했을 때, 상수는 최단 경로로 이동하기 위해 아래와 같은 조건을 만족하며 이동합니다.

1≤i,j<n이라면, 상수는 A[i][j+1] 또는 A[i+1][j]로만 건너갑니다.
i=n,1≤j<n이라면, A[i][j+1]로만 건너갑니다.
1≤i<n,j=n이라면 A[i+1][j]로만 건너갑니다.
i=j=n인 경우 바로 출구로 갑니다.

<p align ='center'><img src ="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11909/2.png"></p>

<p align='center'>[그림 2] n=5라고 가정합시다. (ㄱ)는 1번 조건을 만족하고, (ㄴ)는 2번 조건을 만족하며, (ㄷ)는 3번 조건을 만족합니다.</p>

그러나 건너갈 때에도 제약이 따릅니다. 상수가 A[a][b]에서 A[c][d]로 건너가려면 A[a][b]>A[c][d]를 만족해야 합니다. 상수는 왜인지 이런 조건을 만족하면서 이동할 수 없을 것 같았습니다. 다행히도, 승현이가 상수를 배열에 가둬버리기 전에, 상수는 배열의 각 원소에 버튼을 만들어 놓아서, 이 버튼을 누르면 해당 원소의 값이 1 증가하도록 했습니다. (물론 상수는 자신이 위치해 있는 원소의 버튼만 누를 수 있습니다.) 이 버튼 덕분에, 상수는 항상 배열을 탈출할 수 있습니다!


<p align='center'><img src = "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11909/3.png"></p>

<p align='center'>[그림 3] n=2라고 가정합시다. A[1][1]=5>A[1][2]=2이므로, 상수는 A[1][1]에서 A[1][2]로 건너갈 수 있습니다. 상수가 A[1][1]에서 A[2][1]로 건너가려면, A[1][1]에 있는 버튼을 두 번 눌러 A[1][1]의 값을 7로 만들면 됩니다.</p>

하지만 버튼을 한 번 누르는 데에는 1원의 비용이 듭니다. 상수는 돈을 가능한 한 적게 들이면서 배열을 탈출하고자 합니다. 상수를 도와주세요.

## 입력
첫 번째 줄에 n이 주어집니다. (n ≤ 2,222)

다음에 n개 줄이 주어집니다. 이 중 i(1≤i≤n)번째 줄에는 n개의 수 A[i][1],A[i][2],⋯,A[i][n−1],A[i][n]이 공백을 사이로 두고 차례대로 주어집니다.

## 출력
첫 번째 줄에 상수가 배열을 탈출하기 위해 들여야 할 최소 비용(원 단위)을 출력합니다.

<div class="col-md-12">
				<section id="hint" class="problem-section">
				<div class="headline">
				<h2>힌트</h2>
				</div>
				<div id="problem_hint" class="problem-text">
				<p>상수는 아래 그림과 같은 방법으로 탈출할 수 있습니다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11909/4.png" style="height:202px; width:640px"></p>

<p>이렇게 하면 A[1][1]에서 2원, A[3][2]에서 1원의 비용이 들어 총 3원의 비용이 들게 되며, 이것이 최소입니다.</p>

</div>
</section>
</div>

## 풀이
 - 최소 비용을 저장하는 cost 배열 선언
 - 방문하는 칸에 최소 비용을 저장
 - 현재 위치에서 다음 칸으로 갈 수 있으면 (문제 조건 : 현재 값이 다음 칸의 값보다 크면) 다음 칸의 최소 비용을 **현재 칸까지의 비용**과 **다음 칸에 저장되어 있는 비용** 중 **최솟값**으로 셋팅
 - 갈 수 없으면 **현재 칸의 비용 + 눌러야하는 버튼 비용(다음 칸 - 현재 칸 + 1)** 과 **다음 칸에 저장되어 있는 비용** 중 **최솟값**으로 셋팅
```
  다익스트라의 이전의 경로를 이용하여 최소거리를 갱신하는 개념을 응용한 문제
  다음 칸으로 가는 최단 거리는 (이전 칸 -> 다른 경로 -> 다음 칸), (이전 칸 -> 다음 칸) 처럼 두 경우로 나눌 수 있다.
  즉, 이전 칸의 최단 거리를 참고하여 최단 거리를 측정하는 방식이다.
```
