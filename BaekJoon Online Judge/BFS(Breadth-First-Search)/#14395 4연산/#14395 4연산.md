# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" class="solvedac-tier" width = 20> [4연산](https://www.acmicpc.net/problem/14395)

## 문제
정수 s가 주어진다. 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 프로그램을 작성하시오.

사용할 수 있는 연산은 아래와 같다.

1. s = s + s; (출력: +)
2. s = s - s; (출력: -)
3. s = s * s; (출력: *)
4. s = s / s; (출력: /) (s가 0이 아닐때만 사용 가능)

## 입력
첫째 줄에 s와 t가 주어진다. (1 ≤ s, t ≤ 109)

## 출력
첫째 줄에 정수 s를 t로 바꾸는 방법을 출력한다. s와 t가 같은 경우에는 0을, 바꿀 수 없는 경우에는 -1을 출력한다. 가능한 방법이 여러 가지라면, 사전 순으로 앞서는 것을 출력한다. 

연산의 아스키 코드 순서는 '*', '+', '-', '/' 이다.

## 풀이
 - 연산자는 경로 구하듯이 구하면 됨
 - s의 입력 범위는 10^9이고 계산 과정에서 값이 더 커질 수 있다.
 - 따라서, visited 체크를 Set 자료구조를 이용하여 해준다. (이미 한 번 계산한 s에 대해서는 더 이상 계산하지 않음)
 - 틀렸던 코드에선 s의 범위가 10^9를 넘어가면 continue 하게 설정해뒀었는데, 입력 범위가 10^9이지 계산 과정에서 10^9를 넘지않는다는 뜻은 아님
 - 계산 과정 중에 s가 t보다 커지면 어차피 0과 1로 돌아가야한다. 따라서, s가 t보다 커지는 경우는 고려하지 않는다.

## 반례
```
1 10
> 무한루프
```
> s == 1인 경우 s의 값이 증가하는 경우는 '+' 밖에 없다. s + s가 계속되는 것이므로 2배씩 커지는 것과 같음. 즉, t가 2^n 이어야 s가 t와 같아질 수 있다.

> s > t인 경우 s의 값이 작아지려면 '-'와 '/' 밖에 없다. 하지만 '-'를 하면 0이 되고 '/'하면 1이 된다.
> 0은 더 이상 값이 변하지 않으므로 계속 진행할 필요가 없고, 1이 되면 위와 같이 s == 1인 경우와 같다. 따라서, s > t 인 경우도 t가 2^n(2의 제곱수)여야한다.
- log2 를 취해서 값이 딱 떨어지게 나오면 2^n(제곱수)를 판별할 수 있다. 
```java
제곱수 판별 방법
log2를 취해서 딱 떨어지면 2의 제곱수이다.
    public static boolean canConvert(int t){
        double log_t = Math.log(t) / Math.log(2);  //자연로그(ln)을 이용하여 밑이 2인 로그를 구현
        
        return (log_t - (int)log_t == 0);
    }
```

### 2^n(제곱수)가 아니어도 변환이 가능한 경우가 존재하는듯하다. (2^n이 아니면 -1을 출력하는 방식으로 제출했더니 Wrong Answer 뜸)
------------------------------------------------------------------------

